# Tema2-SD
Pentru reprezentarea structurii de arbore care sa respecte caracteristicile din enuntul temei am definit o structura denumita 'node' prin care se retin informatii pentru fiecare nod din arbore astfel: campul key retine id-ul nodului, campul 'adr' va memora o lista de adrese rezolvabile de fiecare nod din arbore, nr_adrs reprezinta numarul de adrese rezolvabile de catre un nod (inainte de initializarea ierarhiei) iar child si sibling sunt pointeri catre primul copil al nodului, respectiv catre primul frate al copilului (aflat in arbore pe acelasi nivel cu acesta). Pentru a initializa structura de arbore cu datele preluate din fisierul de intrare 'tree.in' am memorat intial, intr-un vector v id-urile parintilor nodurilor din arbore, construind apoi pe baza acestui vector nodurile din arbore si legaturile intre acestea. Am memorat adresele rezolvabile de fiecare nod intr-un tablou tridimensional, memorand initial in listele de adrese ale fiecarui nod aceste date, iar apoi la initializarea ierarhiei (cerinta 2) am parcurs recursiv arborele pentru a adauga in lista de adrese a fiecarui nod si adresele rezolvabile de nodurile copil ale acestuia. La initilizarea structurii de arbore am folosit, pe langa vectorul alocat dinamic cu indicii parintilor si tabloul tridimensional de adrese, si un vector (denumit fr in main) care memoreaza pentru fiecare nod numarul de adrese rezolvabile de acesta (inaintea initializarii ierarhiei de adrese). In cadrul cerintei 1 (afisarea nodurilor si copiilor fiecarui nod, implementata prin functia printKids), am parcurs recursiv structura arborelui pornind de la radacina acestuia pentru care am afisat valoarea campului key, urmata de valorile stocate in campul key al copilului nodului si al fratilor acestuia. Pentru a cobori pe nivelurile urmatoare din arbore am autoapelat functia, o data pornind de la copilul nodului curent si apoi pornind de la fratele acestuia.
Pentru initializarea arborelui folosind vectorul cu valorile indicilor parintilor, am definit functia initTree care foloseste pentru crearea de noi noduri functia addChild (pentru a adauga un nod copil la un anumit nod din arbore). Functia addChild returneaza adresa nodului care tocmai a fost inserat in arbore (aceasta foloseste se asemenea functiile addSibling (pentru a adauga un nod ca frate al unui nod copil)- aceasta functie este apelata atunci cand nodul pentru care se doreste sa se adauga un nod copil are deja cel putin un copil reprezentat in arbore, si functia newNode (pentru a aloca memorie pentru un nod nou)). Am intializat radacina arborelui cu valoarea -1 si apoi am adaugat un copil cu valoarea 0 la radacina, mutand radacina in nodul cu valoarea 0. In cadrul functiei de initTree am pornit de la radacina arborelui (nodul cu valoarea 0), parcurgand vectorul cu indicii parintilor, adaugand intial la radacina copiii nodului 0 si adresele rezolvabile in lista de adrese a fiecarui nod inserat; la pasul urmator, se vor insera in arbore copii pornind de la copiii nodului inserat la pasul precedent, prin apeluri recursive ale functiei initTree. Functia se va autoapela pana cand vor fi adaugate in arbore toate nodurile, parcurgand toate valorile stocate in vectorul cu indicii parintilor.
Pentru memorarea structurii de user, necesara in cadrul cerintelor 3 si 4, am definit o structura de tip lista care stocheaza pentru fiecare utilizator un id si un id pentru nodul la care acesta este conectat. Am realizat memorarea acestor date in lista de useri parcurgand fisierul users.in (in cadrul functiei usersConnection) si apeland functia addUser care primeste ca parametri adresa listei de useri si valorile care se insereaza pentru campurile key si server (id-ul userului si id-ul serverului). Pentru a rezolva cererile de la utilizatori am parcurs linie cu linie fisierul queries.in, stocand in sirul de caractere command fiecare linie si extragand din acest sir informatiile necesare (identificatorul utilizatorului si adresa cautata de acesta). Rezolvarea cererilor utilizatorilor se face in cadrul functiei goToAddress. Aceasta functie verifica daca o anume adresa se gaseste in lista de adrese a unui nod din arbore (cel la care conectat un user).In cazul in care nu este gasita adresa imediat in lista de adrese a nodului curent, aceasta se va cauta in lista de adrese a parintelui acestui nod (functia prin care se determina parintele unui nod este 'getParrent'). Cautarea adresei se continua in lista de adrese a parintelui parintelui nodului de la care s-a pornit cautarea, apeland recursiv functia goToParrentAddress. La fiecare pas, adresa cautata se va adauga in lista de adrese a nodului prin care se trece pana la gasirea sa. Pentru rezolvarea cererilor de eliminare a unui nod, initial am inlocuit in lista de useri id-ul nodului care urma sa se elimine cu id-ul nodului parinte al acestuia, apoi am adaugat copiii nodului sters in lista de adrese a nodului sau parinte si in final am eliminat nodul respectiv din arbore.
Horovei Andreea-Georgiana
315CC
